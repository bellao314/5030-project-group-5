import{bx as e,dw as t,fl as s,G as i,fm as o,fn as n,w as r,di as a,fo as l,aP as c,aZ as h,b3 as u,fp as d,fq as f,fr as p,fs as g,ft as m,fu as y,B as w,fv as b,I as v,bb as x,fw as I,ac as S,fx as M,fy as P,b4 as T,fz as _,fA as k,fB as L,ba as z,eb as j,E as C,aL as D,aK as O,aM as F,fC as A,bt as Z,fD as B,bs as N,bu as R,am as E,P as Y,fE as X,aG as G,aJ as J,c4 as $,U as V,m as U,fF as q,fG as W,fH as H,d8 as Q,fI as K,fJ as ee,x as te,cm as se,z as ie,fK as oe,fL as ne,fM as re}from"./shared.js";function ae(e){const t=e?e.url.toString():void 0;return t?performance.getEntriesByName(t):[]}function le(e){if("number"==typeof e||"boolean"==typeof e||"string"==typeof e||null==e)return JSON.stringify(e);if(Array.isArray(e)){let t="[";for(const s of e)t+=`${le(s)},`;return`${t}]`}let t="{";for(const s of Object.keys(e).sort())t+=`${s}:${le(e[s])},`;return`${t}}`}function ce(t){let s="";for(const i of e)s+=`/${le(t[i])}`;return s}function he(e,t){return function e(s){return"string"==typeof s&&s===t||(Array.isArray(s)?s.some(e):!(!s||"object"!=typeof s)&&Object.values(s).some(e))}(e)}class ue{constructor(e){this.keyCache=Object.create(null),this._layers=Object.create(null),this._layerConfigs=Object.create(null),e&&this.replace(e)}replace(e,t){this._layerConfigs=Object.create(null),this._layers=Object.create(null),this.update(e,[],t)}update(e,s,i){this._options=i;for(const s of e)this._layerConfigs[s.id]=s,(this._layers[s.id]=t(s,this.scope,null,this._options)).compileFilter(i),this.keyCache[s.id]&&delete this.keyCache[s.id];for(const e of s)delete this.keyCache[e],delete this._layerConfigs[e],delete this._layers[e];this.familiesBySource=Object.create(null);const o=function(e,t){const s=Object.create(null);for(let i=0;i<e.length;i++){const o=e[i];let n=t&&t[o.id];n||("symbol"===o.type?n=o.id:(n=ce(o),"line"===o.type&&o.paint&&he(o.paint["line-width"],"line-progress")&&(n+=`/${le(o.paint["line-width"])}`))),t&&(t[o.id]=n);let r=s[n];r||(r=s[n]=[]),r.push(o)}const i=[];for(const e in s)i.push(s[e]);return i}(Object.values(this._layerConfigs),this.keyCache);for(const e of o){const t=e.map(e=>this._layers[e.id]),s=t[0];if("none"===s.visibility)continue;const i=s.source||"";let o=this.familiesBySource[i];o||(o=this.familiesBySource[i]=Object.create(null));const n=s.sourceLayer||"_geojsonTileLayer";let r=o[n];r||(r=o[n]=[]),r.push(t)}}}const de=1*n;class fe{constructor(e){const t={},s=[];for(const i in e){const o=e[i],n=t[i]={};for(const e in o.glyphs){const t=o.glyphs[+e];if(!t||0===t.bitmap.width||0===t.bitmap.height)continue;const i=t.metrics.localGlyph?de:1,r={x:0,y:0,w:t.bitmap.width+2*i,h:t.bitmap.height+2*i};s.push(r),n[e]=r}}const{w:n,h:r}=i(s),a=new o({width:n||1,height:r||1});for(const s in e){const i=e[s];for(const e in i.glyphs){const n=i.glyphs[+e];if(!n||0===n.bitmap.width||0===n.bitmap.height)continue;const r=t[s][e],l=n.metrics.localGlyph?de:1;o.copy(n.bitmap,a,{x:0,y:0},{x:r.x+l,y:r.y+l},n.bitmap)}}this.image=a,this.positions=t}}function pe(e,t,s){e[t]?s&&(e[t].center=s):e[t]={floorIds:new Set,center:s||[0,0],floors:{}}}function ge(e,t,s,i){for(const o of t)pe(e,o),e[o].floors[s]=i,e[o].floorIds.add(s)}function me(e){return{id:e.properties.id.toString(),center:[e.properties.center_lon||0,e.properties.center_lat||0]}}function ye(e,t){const s=e.properties.id.toString(),i=!!e.properties.is_default&&e.properties.is_default,o=e.properties.connected_floor_ids?new Set(e.properties.connected_floor_ids.toString().split(";")):new Set,n=e.properties.conflicted_floor_ids?new Set(e.properties.conflicted_floor_ids.toString().split(";")):new Set,r=e.properties.structure_ids?new Set(e.properties.structure_ids.toString().split(";")):new Set,a=e.properties.name.toString(),c=e.properties.z_index,h=function(e,t){const s=e.loadGeometry();if(!s||0===s.length)return;const i=s.map(s=>s.map(s=>l(s,t,e.extent)));return 0===i.length?void 0:{type:"Polygon",coordinates:[i[0]]}}(e,t);return{id:s,isDefault:i,connections:o,conflicts:n,buildings:r,name:a,zIndex:c,geometry:h}}function we(e,t){return t.every(t=>e.properties&&null!=e.properties[t])}function be(e){return we(e,["type","id","name"])&&"structure"===e.properties.type}function ve(e){return we(e,["type","id","name","z_index"])&&"floor"===e.properties.type}s(fe,"GlyphAtlas");class xe{constructor(e){this.tileID=new c(e.tileID.overscaledZ,e.tileID.wrap,e.tileID.canonical.z,e.tileID.canonical.x,e.tileID.canonical.y),this.tileZoom=e.tileZoom,this.uid=e.uid,this.zoom=e.zoom,this.lut=e.lut,this.canonical=e.tileID.canonical,this.pixelRatio=e.pixelRatio,this.tileSize=e.tileSize,this.source=e.source,this.scope=e.scope,this.overscaling=this.tileID.overscaleFactor(),this.showCollisionBoxes=e.showCollisionBoxes,this.collectResourceTiming=!!e.request&&e.request.collectResourceTiming,this.promoteId=e.promoteId,this.isSymbolTile=e.isSymbolTile,this.tileTransform=h(e.tileID.canonical,e.projection),this.projection=e.projection,this.worldview=e.worldview,this.localizableLayerIds=e.localizableLayerIds,this.brightness=e.brightness,this.extraShadowCaster=!!e.extraShadowCaster,this.tessellationStep=e.tessellationStep,this.scaleFactor=e.scaleFactor,this.worldview=e.worldview,this.indoor=e.indoor}parse(e,t,s,i,o,n){this.status="parsing",this.data=e,this.collisionBoxArray=new u;const l=new d(Object.keys(e.layers).sort()),c=new f(this.tileID,this.promoteId);c.bucketLayerIDs=[];const h={},S=new p(256,256),C={featureIndex:c,iconDependencies:new Map,patternDependencies:new Map,glyphDependencies:{},lineAtlas:S,availableImages:s,brightness:this.brightness,scaleFactor:this.scaleFactor,elevationFeatures:void 0,activeFloors:void 0};this.indoor&&(C.activeFloors=function(e,t,s,i){const o=t.indoorState.activeFloorsVisible;if(!t.sourceLayers)return o?t.indoorState.activeFloors:void 0;const n=function(e,t){if(!e)return r("No source layers defined in indoor specification"),t;if(0===e.size)return t;const s=e.difference(t);for(const e of s)r(`Missing source layer required in indoor specification: ${e}`);return t.intersection(t)}(t.sourceLayers,new Set(Object.keys(e.layers))),l=t.indoorState,c=function(e,t,s,i,o){const n={};for(const s of t){const t=e.layers[s];if(t)for(let e=0;e<t.length;e++){const s=t.feature(e);if(be(s)){const{id:e,center:t}=me(s);pe(n,e,t);continue}if(ve(s)){const e=ye(s,o);ge(n,e.buildings,e.id,e)}}else r(`indoor source layer not found: ${s}`)}return{buildings:n,activeFloors:a.calculate(n,i,s)}}(e,n,l.activeFloors,l.selectedFloorId,i);return s.send("setIndoorData",c),o?c.activeFloors:void 0}(e,this.indoor,o,this.canonical));const D=[],O=t.familiesBySource[this.source];for(const t in O){const o=e.layers[t];if(!o)continue;let n=!1,a=!1,u=!1;for(const e of O[t])"symbol"===e[0].type?n=!0:a=!0,e[0].is3D()&&"model"!==e[0].type&&(u=!0);if(this.extraShadowCaster&&!u)continue;if(!0===this.isSymbolTile&&!n)continue;if(!1===this.isSymbolTile&&!a)continue;1===o.version&&r(`Vector tile source "${this.source}" layer "${t}" does not use vector tile spec v2 and therefore may have some rendering errors.`);const d=l.encode(t),f=[],p=this.localizableLayerIds&&this.localizableLayerIds.has(t);let b=!1;for(let e=0,s=0;e<o.length;e++){const i=o.feature(e),n=c.getId(i,t),r=i.properties?i.properties.worldview:null;if(p&&this.worldview&&"string"==typeof r)if("all"===r)i.properties.$localized=!0;else{if(!r.split(",").includes(this.worldview))continue;i.properties.$localized=!0,i.properties.worldview=this.worldview}!b&&i.properties&&i.properties.hasOwnProperty(g)&&(b=!0),f.push({feature:i,id:n,index:s,sourceLayerIndex:d}),s++}b&&!C.elevationFeatures&&e.layers.hasOwnProperty(m)&&(C.elevationFeatures=y.parseFrom(e.layers[m],this.canonical));for(const e of O[t]){const t=e[0];if(this.extraShadowCaster&&(!t.is3D()||"model"===t.type))continue;if(void 0!==this.isSymbolTile&&"symbol"===t.type!==this.isSymbolTile)continue;if(t.minzoom&&this.zoom<Math.floor(t.minzoom))continue;if(t.maxzoom&&this.zoom>=t.maxzoom)continue;if("none"===t.visibility)continue;Ie(e,this.zoom,C.brightness,s,this.worldview,C.activeFloors);const o=h[t.id]=t.createBucket({index:c.bucketLayerIDs.length,layers:e,zoom:this.zoom,lut:this.lut,canonical:this.canonical,pixelRatio:this.pixelRatio,overscaling:this.overscaling,collisionBoxArray:this.collisionBoxArray,sourceLayerIndex:d,sourceID:this.source,projection:this.projection.spec,tessellationStep:this.tessellationStep,styleDefinedModelURLs:i,worldview:this.worldview,localizable:p,availableImages:s});c.bucketLayerIDs.push(e.map(e=>w(e.id,e.scope)));let n=o.prepare?o.prepare():null;null!=n?(n=n.then(()=>o.populate(f,C,this.tileID.canonical,this.tileTransform)),D.push(n)):o.populate(f,C,this.tileID.canonical,this.tileTransform)}}const F=()=>{let t,i,r,a,u,d;S.trim();const f={type:"maybePrepare",isSymbolTile:this.isSymbolTile,zoom:this.zoom},p=()=>{if(t)return this.status="done",n(t);if(this.extraShadowCaster)this.status="done",n(null,{buckets:Object.values(h).filter(e=>!e.isEmpty()),featureIndex:c,collisionBoxArray:null,glyphAtlasImage:null,lineAtlas:null,imageAtlas:null,brightness:C.brightness,glyphMap:null,iconMap:null,glyphPositions:null});else if(i&&r&&a){const e=new fe(i),t=new Map;for(const[e,s]of r.entries()){const{imagePosition:i}=M(e,s,P);t.set(e,i)}const n={};for(const o in h){const a=h[o];a instanceof T&&(Ie(a.layers,this.zoom,C.brightness,s,this.worldview,C.activeFloors),n[o]=_(a,i,e.positions,r,t,this.tileID.canonical,this.tileZoom,this.scaleFactor,this.pixelRatio,u,this.worldview,s))}const l={iconsPending:!0,patternsPending:!0};this.rasterizeIfNeeded(o,r,u,()=>{l.iconsPending=!1,g(n,e,l)}),this.rasterizeIfNeeded(o,a,d,()=>{l.patternsPending=!1,g(n,e,l)})}},g=(e,t,i,o)=>{if(i.iconsPending||i.patternsPending)return;const l=new k(r,a,this.lut);for(const t in h){const i=h[t];if(t in e)L(i,e[t],this.showCollisionBoxes,s,this.tileID.canonical,this.tileZoom,this.projection,this.brightness,r,l);else if(i.hasPattern&&(i instanceof z||i instanceof x||i instanceof j)){Ie(i.layers,this.zoom,C.brightness,s,this.worldview,C.activeFloors);const e=Object.fromEntries(l.patternPositions);i.addFeatures(C,this.tileID.canonical,e,s,this.tileTransform,this.brightness)}}this.status="done",n(null,{buckets:Object.values(h).filter(e=>!e.isEmpty()),featureIndex:c,collisionBoxArray:this.collisionBoxArray,glyphAtlasImage:t.image,lineAtlas:S,imageAtlas:l,brightness:C.brightness})};if(!this.extraShadowCaster){const e=b(C.glyphDependencies,e=>Object.keys(e).map(Number));Object.keys(e).length?o.send("getGlyphs",{uid:this.uid,stacks:e},(e,s)=>{t||(t=e,i=s,p())},void 0,!1,f):i={};const s=Array.from(C.iconDependencies.keys()).map(e=>v.parse(e));s.length?o.send("getImages",{images:s,source:this.source,scope:this.scope,tileID:this.tileID,type:"icons"},(e,s)=>{t||(t=e,r=new Map,u=this.updateImageMapAndGetImageTaskQueue(r,s,C.iconDependencies),p())},void 0,!1,f):(r=new Map,u=new Map);const n=Array.from(C.patternDependencies.keys()).map(e=>v.parse(e));n.length?o.send("getImages",{images:n,source:this.source,scope:this.scope,tileID:this.tileID,type:"patterns"},(e,s)=>{t||(t=e,a=new Map,d=this.updateImageMapAndGetImageTaskQueue(a,s,C.patternDependencies),p())},void 0,!1,f):(a=new Map,d=new Map)}if(C.elevationFeatures&&C.elevationFeatures.length>0){const t=[];for(const e of Object.values(h))if(e instanceof x){const s=e.getUnevaluatedPortalGraph();s&&t.push(s)}const s=I.evaluate(t);for(const t of Object.values(h))if(t instanceof x){const i=e.layers[l.decode(t.sourceLayerIndex)];t.setEvaluatedPortalGraph(s,i,this.tileID.canonical,C.availableImages,C.brightness)}}p()};D.length>0?Promise.allSettled(D).then(F).catch(n):F()}updateParameters(e){this.scaleFactor=e.scaleFactor,this.showCollisionBoxes=e.showCollisionBoxes,this.projection=e.projection,this.brightness=e.brightness,this.tileTransform=h(e.tileID.canonical,e.projection),this.extraShadowCaster=e.extraShadowCaster,this.lut=e.lut,this.worldview=e.worldview,this.indoor=e.indoor}rasterizeIfNeeded(e,t,s,i){Array.from(t.values()).some(e=>e.usvg)?this.rasterize(e,t,s,i):i()}updateImageMapAndGetImageTaskQueue(e,t,s){const i=new Map;for(const o of t.keys()){const n=s.get(o)||[];for(const s of n){const o=s.toString(),n=t.get(s.id.toString());n.usvg?i.has(o)||(i.set(o,s),e.set(o,Object.assign({},n))):e.set(o,n)}}return i}rasterize(e,t,s,i){this.rasterizeTask=e.send("rasterizeImages",{scope:this.scope,tasks:s},(e,s)=>{if(!e)for(const[e,i]of s.entries()){const s=Object.assign(t.get(e),{data:i});t.set(e,s)}i()})}cancelRasterize(){this.rasterizeTask&&this.rasterizeTask.cancel()}}function Ie(e,t,s,i,o,n){const r=new S(t,{brightness:s,worldview:o,activeFloors:n});for(const t of e)t.recalculate(r,i)}class Se extends C{constructor(e,t,s,i,o,n,r){super(),this.actor=e,this.layerIndex=t,this.availableImages=s,this.availableModels=i,this.loadVectorData=n||D,this.loading={},this.loaded={},this.deduped=new O(e.scheduler),this.isSpriteLoaded=o,this.scheduler=e.scheduler,this.brightness=r}loadTile(e,t){const s=e.uid,i=e&&e.request,o=i&&i.collectResourceTiming,n=this.loading[s]=new xe(e);n.abort=this.loadVectorData(e,(r,a)=>{const l=!this.loading[s];if(delete this.loading[s],n.cancelRasterize(),l||r||!a)return n.status="done",l||(this.loaded[s]=n),t(r);const c=a.rawData,h={},u=F(a.responseHeaders);u&&u.expires&&(h.expires=u.expires),u&&u.cacheControl&&(h.cacheControl=u.cacheControl),n.vectorTile=a.vectorTile||new A(new Z(c));const d=()=>{n.parse(n.vectorTile,this.layerIndex,this.availableImages,this.availableModels,this.actor,(e,s)=>{if(e||!s)return t(e);const n={};if(o){const e=ae(i);e.length>0&&(n.resourceTiming=JSON.parse(JSON.stringify(e)))}t(null,Object.assign({rawTileData:c.slice(0),responseHeaders:a.responseHeaders},s,h,n))})};this.isSpriteLoaded?d():this.once("isSpriteLoaded",()=>{this.scheduler?this.scheduler.add(d,{type:"parseTile",isSymbolTile:e.isSymbolTile,zoom:e.tileZoom}):d()}),this.loaded=this.loaded||{},this.loaded[s]=n})}reloadTile(e,t){const s=this.loaded,i=e.uid;if(s&&s[i]){const o=s[i];o.updateParameters(e);const n=(e,s)=>{const i=o.reloadCallback;i&&(delete o.reloadCallback,o.parse(o.vectorTile,this.layerIndex,this.availableImages,this.availableModels,this.actor,i)),t(e,s)};"parsing"===o.status?o.reloadCallback=n:"done"===o.status&&(o.vectorTile?o.parse(o.vectorTile,this.layerIndex,this.availableImages,this.availableModels,this.actor,n):n())}else t(null,void 0)}abortTile(e,t){const s=e.uid,i=this.loading[s];i&&(i.abort&&i.abort(),delete this.loading[s]),t()}removeTile(e,t){const s=this.loaded,i=e.uid;s&&s[i]&&delete s[i],t()}}class Me{loadTile(e,t){const{uid:s,encoding:i,rawImageData:o,padding:n}=e,r=ImageBitmap&&o instanceof ImageBitmap?this.getImageData(o,n):o;t(null,new B(s,r,i,n<1))}reloadTile(e,t){t(null,null)}abortTile(e,t){t()}removeTile(e,t){t()}getImageData(e,t){this.offscreenCanvas&&this.offscreenCanvasContext||(this.offscreenCanvas=new OffscreenCanvas(e.width,e.height),this.offscreenCanvasContext=this.offscreenCanvas.getContext("2d",{willReadFrequently:!0})),this.offscreenCanvas.width=e.width,this.offscreenCanvas.height=e.height,this.offscreenCanvasContext.drawImage(e,0,0,e.width,e.height);const s=this.offscreenCanvasContext.getImageData(-t,-t,e.width+2*t,e.height+2*t);return this.offscreenCanvasContext.clearRect(0,0,this.offscreenCanvas.width,this.offscreenCanvas.height),s}}N.setPbf(Z);class Pe{constructor(e){this._mrt=new N(e.partial?30:1/0),this._isHeaderLoaded=!1,this.uid=e.uid,this.tileID=e.tileID,this.source=e.source}parse(e,t){const s=this._mrt;this.status="parsing",this._entireBuffer=e;try{s.parseHeader(e),this._isHeaderLoaded=!0;const i=[];for(const t in s.layers){const o=s.getLayer(t),n=o.getDataRange(o.getBandList()),r=s.createDecodingTask(n),a=e.slice(n.firstByte,n.lastByte+1),l=N.performDecoding(a,r).then(e=>r.complete(null,e)).catch(e=>r.complete(e,null));i.push(l)}Promise.allSettled(i).then(()=>t(null,s)).catch(e=>t(e))}catch(e){t(e)}}}class Te{constructor(e){this.actor=e,this.loading={},this.loaded={}}loadTile(e,t){const s=e.uid,i=e.request,o=this.loading[s]=new Pe(e),{cancel:n}=R(i,(e,i,n)=>{const r=!this.loading[s];if(delete this.loading[s],r||e||!i)return o.status="done",r||(this.loaded[s]=o),t(e);o.parse(i,(e,s)=>{if(e||!s)return t(e);t(null,s,n)}),this.loaded[s]=o});o.abort=n}reloadTile(e,t){t(null,void 0)}abortTile(e,t){const s=e.uid,i=this.loading[s];i&&(i.abort&&i.abort(),delete this.loading[s]),t()}removeTile(e,t){const s=e.uid;this.loaded[s]&&delete this.loaded[s],t()}decodeRasterArray(e,t){N.performDecoding(e.buffer,e.task).then(e=>t(null,e)).catch(e=>t(e))}}const _e=X.prototype.toGeoJSON;class ke{constructor(e){this._feature=e,this.extent=E,this.type=e.type,this.properties=e.tags,"id"in e&&!isNaN(e.id)&&(this.id=parseInt(e.id,10))}loadGeometry(){if(1===this._feature.type){const e=[];for(const t of this._feature.geometry)e.push([new Y(t[0],t[1])]);return e}{const e=[];for(const t of this._feature.geometry){const s=[];for(const e of t)s.push(new Y(e[0],e[1]));e.push(s)}return e}}toGeoJSON(e,t,s){return _e.call(this,e,t,s)}}class Le{constructor(e,t){this.name=e,this.extent=E,this.length=t.length,this._jsonFeatures=t}feature(e){return new ke(this._jsonFeatures[e])}}class ze{constructor(e){this.layers={},this.extent=E;for(const t of Object.keys(e))this.layers[t]=new Le(t,e[t])}}const je=64/4096;class Ce{constructor(){this.features=new Map}clear(){this.features.clear()}load(e=[],t){for(const s of e){const e=s.id;if(null==e)continue;let i=this.features.get(e);i&&this.updateCache(i,t),s.geometry?(i=Oe(s),this.updateCache(i,t),this.features.set(e,i)):this.features.delete(e),this.updateCache(i,t)}}updateCache(e,t){for(const{canonical:s,uid:i}of Object.values(t)){const{z:o,x:n,y:r}=s;De(e,Math.pow(2,o),n,r)&&delete t[i]}}getTile(e,t,s){const i=Math.pow(2,e),o=[];for(const e of this.features.values())De(e,i,t,s)&&o.push(Be(e,i,t,s));return{features:o}}getFeatures(){return[...this.features.values()]}}function De({minX:e,minY:t,maxX:s,maxY:i},o,n,r){return e<(n+1+je)/o&&t<(r+1+je)/o&&s>(n-je)/o&&i>(r-je)/o}function Oe(e){const{id:t,geometry:s,properties:i}=e;if(!s)return;if("GeometryCollection"===s.type)throw new Error("GeometryCollection not supported in dynamic mode.");const{type:o,coordinates:n}=s,r={id:t,type:1,geometry:[],tags:i,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0},a=r.geometry;if("Point"===o)Fe(n,a,r);else if("MultiPoint"===o)for(const e of n)Fe(e,a,r);else if("LineString"===o)r.type=2,Ae(n,a,r);else if("MultiLineString"===o)r.type=2,Ze(n,a,r);else if("Polygon"===o)r.type=3,Ze(n,a,r,!0);else{if("MultiPolygon"!==o)throw new Error("Input data is not a valid GeoJSON object.");r.type=3;for(const e of n)Ze(e,a,r,!0)}return r}function Fe([e,t],s,i){const o=G(e);let n=J(t);n=n<0?0:n>1?1:n,s.push(o,n),i.minX=Math.min(i.minX,o),i.minY=Math.min(i.minY,n),i.maxX=Math.max(i.maxX,o),i.maxY=Math.max(i.maxY,n)}function Ae(e,t,s,i=!1,o=!1){const n=[];for(const t of e)Fe(t,n,s);t.push(n),i&&function(e,t){let s=0;for(let t=0,i=e.length,o=i-2;t<i;o=t,t+=2)s+=(e[t]-e[o])*(e[t+1]+e[o+1]);if(s>0===t)for(let t=0,s=e.length;t<s/2;t+=2){const i=e[t],o=e[t+1];e[t]=e[s-2-t],e[t+1]=e[s-1-t],e[s-2-t]=i,e[s-1-t]=o}}(n,o)}function Ze(e,t,s,i=!1){for(let o=0;o<e.length;o++)Ae(e[o],t,s,i,0===o)}function Be(e,t,s,i){const{id:o,type:n,geometry:r,tags:a}=e,l=[];if(1===n)!function(e,t,s,i,o){for(let n=0;n<e.length;n+=2){const r=Math.round(E*(e[n+0]*t-s)),a=Math.round(E*(e[n+1]*t-i));o.push([r,a])}}(r,t,s,i,l);else if(2===n)for(const e of r)Ne(e,t,s,i,l);else if(3===n)for(const e of r)Re(e,t,s,i,l);return{id:o,type:n,geometry:l,tags:a}}function Ne(e,t,s,i,o){const n=-128,r=E+128;let a;for(let l=0;l<e.length-2;l+=2){let c=Math.round(E*(e[l+0]*t-s)),h=Math.round(E*(e[l+1]*t-i)),u=Math.round(E*(e[l+2]*t-s)),d=Math.round(E*(e[l+3]*t-i));const f=u-c,p=d-h;c<n&&u<n||(c<n?(h+=Math.round(p*((n-c)/f)),c=n):u<n&&(d=h+Math.round(p*((n-c)/f)),u=n),h<n&&d<n||(h<n?(c+=Math.round(f*((n-h)/p)),h=n):d<n&&(u=c+Math.round(f*((n-h)/p)),d=n),c>=r&&u>=r||(c>=r?(h+=Math.round(p*((r-c)/f)),c=r):u>=r&&(d=h+Math.round(p*((r-c)/f)),u=r),h>=r&&d>=r||(h>=r?(c+=Math.round(f*((r-h)/p)),h=r):d>=r&&(u=c+Math.round(f*((r-h)/p)),d=r),a&&c===a[a.length-1][0]&&h===a[a.length-1][1]||(a=[[c,h]],o.push(a)),a.push([u,d])))))}}function Re(e,t,s,i,o){const n=(s-je)/t,r=(i-je)/t,a=(s+1+je)/t,l=(i+1+je)/t;function c(e,t){let s=0;return e<n?s|=1:e>a&&(s|=2),t<r?s|=4:t>l&&(s|=8),s}let h=[];for(let t=1;t<=8;t*=2){let s=e[e.length-2],i=e[e.length-1],o=!(c(s,i)&t);for(let u=0;u<e.length;u+=2){const d=e[u],f=e[u+1],p=!(c(d,f)&t);p!==o&&(8&t?h.push(s+(d-s)*(l-i)/(f-i),l):4&t?h.push(s+(d-s)*(r-i)/(f-i),r):2&t?h.push(a,i+(f-i)*(a-s)/(d-s)):1&t&&h.push(n,i+(f-i)*(n-s)/(d-s))),p&&h.push(d,f),s=d,i=f,o=p}if(!(e=h).length||8===t)break;h=[]}const u=[];for(let e=0;e<h.length;e+=2)u.push([Math.round(E*(h[e]*t-s)),Math.round(E*(h[e+1]*t-i))]);u.length&&o.push(u)}function Ee({name:e,features:t},s){s.writeStringField(1,e),s.writeVarintField(5,E);const i=new Map,o=new Map,n={keys:i,values:o,feature:null};for(const e of t)n.feature=e,s.writeMessage(2,Ye,n);for(const e of i.keys())s.writeStringField(3,e);for(const e of o.keys())s.writeMessage(4,Ve,e)}function Ye(e,t){const s=e.feature;void 0!==s.id&&Number.isSafeInteger(+s.id)&&t.writeVarintField(1,+s.id),s.tags&&t.writeMessage(2,Xe,e),t.writeVarintField(3,s.type),t.writeMessage(4,$e,s)}function Xe({keys:e,values:t,feature:s},i){for(const o of Object.keys(s.tags)){let n=s.tags[o];if(null===n)continue;let r=e.get(o);void 0===r&&(r=e.size,e.set(o,r)),i.writeVarint(r);const a=typeof n;"string"!==a&&"boolean"!==a&&"number"!==a&&(n=JSON.stringify(n));let l=t.get(n);void 0===l&&(l=t.size,t.set(n,l)),i.writeVarint(l)}}function Ge(e,t){return(t<<3)+(7&e)}function Je(e){return e<<1^e>>31}function $e(e,t){const{geometry:s,type:i}=e;let o=0,n=0;if(1===i){t.writeVarint(Ge(1,s.length));for(const e of s){const s=e[0]-o,i=e[1]-n;t.writeVarint(Je(s)),t.writeVarint(Je(i)),o+=s,n+=i}}else for(const e of s){if(0===e.length)continue;t.writeVarint(Ge(1,1));const s=e.length-(3===i?1:0);for(let i=0;i<s;i++){1===i&&t.writeVarint(Ge(2,s-1));const r=e[i][0]-o,a=e[i][1]-n;t.writeVarint(Je(r)),t.writeVarint(Je(a)),o+=r,n+=a}3===i&&t.writeVarint(Ge(7,1))}}function Ve(e,t){const s=typeof e;"string"===s?t.writeStringField(1,e):"boolean"===s?t.writeBooleanField(7,e):"number"===s&&(e%1!=0?t.writeDoubleField(3,e):e<0?t.writeSVarintField(6,e):t.writeVarintField(5,e))}const Ue={minZoom:0,maxZoom:16,minPoints:2,radius:40,extent:512,nodeSize:64,log:!1,generateId:!1,reduce:null,map:e=>e},qe=Math.fround||(We=new Float32Array(1),e=>(We[0]=+e,We[0]));var We;class He{constructor(e){this.options=Object.assign(Object.create(Ue),e),this.trees=new Array(this.options.maxZoom+1),this.stride=this.options.reduce?7:6,this.clusterProps=[]}load(e){const{log:t,minZoom:s,maxZoom:i}=this.options;t&&console.time("total time");const o=`prepare ${e.length} points`;t&&console.time(o),this.points=e;const n=[];for(let t=0;t<e.length;t++){const s=e[t];if(!s.geometry)continue;const[i,o]=s.geometry.coordinates,r=qe(et(i)),a=qe(tt(o));n.push(r,a,1/0,t,-1,1),this.options.reduce&&n.push(0)}let r=this.trees[i+1]=this._createTree(n);t&&console.timeEnd(o);for(let e=i;e>=s;e--){const s=+Date.now();r=this.trees[e]=this._createTree(this._cluster(r,e)),t&&console.log("z%d: %d clusters in %dms",e,r.numItems,+Date.now()-s)}return t&&console.timeEnd("total time"),this}getClusters(e,t){let s=((e[0]+180)%360+360)%360-180;const i=Math.max(-90,Math.min(90,e[1]));let o=180===e[2]?180:((e[2]+180)%360+360)%360-180;const n=Math.max(-90,Math.min(90,e[3]));if(e[2]-e[0]>=360)s=-180,o=180;else if(s>o){const e=this.getClusters([s,i,180,n],t),r=this.getClusters([-180,i,o,n],t);return e.concat(r)}const r=this.trees[this._limitZoom(t)],a=r.range(et(s),tt(n),et(o),tt(i)),l=r.data,c=[];for(const e of a){const t=this.stride*e;c.push(l[t+5]>1?Qe(l,t,this.clusterProps):this.points[l[t+3]])}return c}getChildren(e){const t=this._getOriginId(e),s=this._getOriginZoom(e),i="No cluster with the specified id.",o=this.trees[s];if(!o)throw new Error(i);const n=o.data;if(t*this.stride>=n.length)throw new Error(i);const r=this.options.radius/(this.options.extent*Math.pow(2,s-1)),a=o.within(n[t*this.stride],n[t*this.stride+1],r),l=[];for(const t of a){const s=t*this.stride;n[s+4]===e&&l.push(n[s+5]>1?Qe(n,s,this.clusterProps):this.points[n[s+3]])}if(0===l.length)throw new Error(i);return l}getLeaves(e,t,s){const i=[];return this._appendLeaves(i,e,t=t||10,s=s||0,0),i}getTile(e,t,s){const i=this.trees[this._limitZoom(e)],o=Math.pow(2,e),{extent:n,radius:r}=this.options,a=r/n,l=(s-a)/o,c=(s+1+a)/o,h={features:[]};return this._addTileFeatures(i.range((t-a)/o,l,(t+1+a)/o,c),i.data,t,s,o,h),0===t&&this._addTileFeatures(i.range(1-a/o,l,1,c),i.data,o,s,o,h),t===o-1&&this._addTileFeatures(i.range(0,l,a/o,c),i.data,-1,s,o,h),h.features.length?h:null}getClusterExpansionZoom(e){let t=this._getOriginZoom(e)-1;for(;t<=this.options.maxZoom;){const s=this.getChildren(e);if(t++,1!==s.length)break;e=s[0].properties.cluster_id}return t}_appendLeaves(e,t,s,i,o){const n=this.getChildren(t);for(const t of n){const n=t.properties;if(n&&n.cluster?o+n.point_count<=i?o+=n.point_count:o=this._appendLeaves(e,n.cluster_id,s,i,o):o<i?o++:e.push(t),e.length===s)break}return o}_createTree(e){const t=new $(e.length/this.stride|0,this.options.nodeSize,Float32Array);for(let s=0;s<e.length;s+=this.stride)t.add(e[s],e[s+1]);return t.finish(),t.data=e,t}_addTileFeatures(e,t,s,i,o,n){for(const r of e){const e=r*this.stride,a=t[e+5]>1;let l,c,h;if(a)l=Ke(t,e,this.clusterProps),c=t[e],h=t[e+1];else{const s=this.points[t[e+3]];l=s.properties;const[i,o]=s.geometry.coordinates;c=et(i),h=tt(o)}const u={type:1,geometry:[[Math.round(this.options.extent*(c*o-s)),Math.round(this.options.extent*(h*o-i))]],tags:l};let d;d=a||this.options.generateId?t[e+3]:this.points[t[e+3]].id,void 0!==d&&(u.id=d),n.features.push(u)}}_limitZoom(e){return Math.max(this.options.minZoom,Math.min(Math.floor(+e),this.options.maxZoom+1))}_cluster(e,t){const{radius:s,extent:i,reduce:o,minPoints:n}=this.options,r=s/(i*Math.pow(2,t)),a=e.data,l=[],c=this.stride;for(let s=0;s<a.length;s+=c){if(a[s+2]<=t)continue;a[s+2]=t;const i=a[s],h=a[s+1],u=e.within(a[s],a[s+1],r),d=a[s+5];let f=d;for(const e of u){const s=e*c;a[s+2]>t&&(f+=a[s+5])}if(f>d&&f>=n){let e,n=i*d,r=h*d,p=-1;const g=(s/c<<5)+(t+1)+this.points.length;for(const i of u){const l=i*c;if(a[l+2]<=t)continue;a[l+2]=t;const h=a[l+5];n+=a[l]*h,r+=a[l+1]*h,a[l+4]=g,o&&(e||(e=this._map(a,s,!0),p=this.clusterProps.length,this.clusterProps.push(e)),o(e,this._map(a,l)))}a[s+4]=g,l.push(n/f,r/f,1/0,g,-1,f),o&&l.push(p)}else{for(let e=0;e<c;e++)l.push(a[s+e]);if(f>1)for(const e of u){const s=e*c;if(!(a[s+2]<=t)){a[s+2]=t;for(let e=0;e<c;e++)l.push(a[s+e])}}}}return l}_getOriginId(e){return e-this.points.length>>5}_getOriginZoom(e){return(e-this.points.length)%32}_map(e,t,s){if(e[t+5]>1){const i=this.clusterProps[e[t+6]];return s?Object.assign({},i):i}const i=this.points[e[t+3]].properties,o=this.options.map(i);return s&&o===i?Object.assign({},o):o}}function Qe(e,t,s){return{type:"Feature",id:e[t+3],properties:Ke(e,t,s),geometry:{type:"Point",coordinates:[(i=e[t],360*(i-.5)),st(e[t+1])]}};var i}function Ke(e,t,s){const i=e[t+5],o=i>=1e4?`${Math.round(i/1e3)}k`:i>=1e3?Math.round(i/100)/10+"k":i,n=e[t+6],r=-1===n?{}:Object.assign({},s[n]);return Object.assign(r,{cluster:!0,cluster_id:e[t+3],point_count:i,point_count_abbreviated:o})}function et(e){return e/360+.5}function tt(e){const t=Math.sin(e*Math.PI/180),s=.5-.25*Math.log((1+t)/(1-t))/Math.PI;return s<0?0:s>1?1:s}function st(e){const t=(180-360*e)*Math.PI/180;return 360*Math.atan(Math.exp(t))/Math.PI-90}function it(e,t,s,i){let o=i;const n=t+(s-t>>1);let r,a=s-t;const l=e[t],c=e[t+1],h=e[s],u=e[s+1];for(let i=t+3;i<s;i+=3){const t=ot(e[i],e[i+1],l,c,h,u);if(t>o)r=i,o=t;else if(t===o){const e=Math.abs(i-n);e<a&&(r=i,a=e)}}o>i&&(r-t>3&&it(e,t,r,i),e[r+2]=o,s-r>3&&it(e,r,s,i))}function ot(e,t,s,i,o,n){let r=o-s,a=n-i;if(0!==r||0!==a){const l=((e-s)*r+(t-i)*a)/(r*r+a*a);l>1?(s=o,i=n):l>0&&(s+=r*l,i+=a*l)}return r=e-s,a=t-i,r*r+a*a}function nt(e,t,s,i){const o={id:e??null,type:t,geometry:s,tags:i,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0};if("Point"===t||"MultiPoint"===t||"LineString"===t)rt(o,s);else if("Polygon"===t)rt(o,s[0]);else if("MultiLineString"===t)for(const e of s)rt(o,e);else if("MultiPolygon"===t)for(const e of s)rt(o,e[0]);return o}function rt(e,t){for(let s=0;s<t.length;s+=3)e.minX=Math.min(e.minX,t[s]),e.minY=Math.min(e.minY,t[s+1]),e.maxX=Math.max(e.maxX,t[s]),e.maxY=Math.max(e.maxY,t[s+1])}function at(e,t,s,i){if(!t.geometry)return;const o=t.geometry.coordinates;if(o&&0===o.length)return;const n=t.geometry.type,r=Math.pow(s.tolerance/((1<<s.maxZoom)*s.extent),2);let a=[],l=t.id;if(s.promoteId?l=t.properties[s.promoteId]:s.generateId&&(l=i||0),"Point"===n)lt(o,a);else if("MultiPoint"===n)for(const e of o)lt(e,a);else if("LineString"===n)ct(o,a,r,!1);else if("MultiLineString"===n){if(s.lineMetrics){for(const s of o)a=[],ct(s,a,r,!1),e.push(nt(l,"LineString",a,t.properties));return}ht(o,a,r,!1)}else if("Polygon"===n)ht(o,a,r,!0);else{if("MultiPolygon"!==n){if("GeometryCollection"===n){for(const o of t.geometry.geometries)at(e,{id:l,geometry:o,properties:t.properties},s,i);return}throw new Error("Input data is not a valid GeoJSON object.")}for(const e of o){const t=[];ht(e,t,r,!0),a.push(t)}}e.push(nt(l,n,a,t.properties))}function lt(e,t){t.push(ut(e[0]),dt(e[1]),0)}function ct(e,t,s,i){let o,n,r=0;for(let s=0;s<e.length;s++){const a=ut(e[s][0]),l=dt(e[s][1]);t.push(a,l,0),s>0&&(r+=i?(o*l-a*n)/2:Math.sqrt(Math.pow(a-o,2)+Math.pow(l-n,2))),o=a,n=l}const a=t.length-3;t[2]=1,it(t,0,a,s),t[a+2]=1,t.size=Math.abs(r),t.start=0,t.end=t.size}function ht(e,t,s,i){for(let o=0;o<e.length;o++){const n=[];ct(e[o],n,s,i),t.push(n)}}function ut(e){return e/360+.5}function dt(e){const t=Math.sin(e*Math.PI/180),s=.5-.25*Math.log((1+t)/(1-t))/Math.PI;return s<0?0:s>1?1:s}function ft(e,t,s,i,o,n,r,a){if(i/=t,n>=(s/=t)&&r<i)return e;if(r<s||n>=i)return null;const l=[];for(const t of e){const e=t.geometry;let n=t.type;const r=0===o?t.minX:t.minY,c=0===o?t.maxX:t.maxY;if(r>=s&&c<i){l.push(t);continue}if(c<s||r>=i)continue;let h=[];if("Point"===n||"MultiPoint"===n)pt(e,h,s,i,o);else if("LineString"===n)gt(e,h,s,i,o,!1,a.lineMetrics);else if("MultiLineString"===n)yt(e,h,s,i,o,!1);else if("Polygon"===n)yt(e,h,s,i,o,!0);else if("MultiPolygon"===n)for(const t of e){const e=[];yt(t,e,s,i,o,!0),e.length&&h.push(e)}if(h.length){if(a.lineMetrics&&"LineString"===n){for(const e of h)l.push(nt(t.id,n,e,t.tags));continue}"LineString"!==n&&"MultiLineString"!==n||(1===h.length?(n="LineString",h=h[0]):n="MultiLineString"),"Point"!==n&&"MultiPoint"!==n||(n=3===h.length?"Point":"MultiPoint"),l.push(nt(t.id,n,h,t.tags))}}return l.length?l:null}function pt(e,t,s,i,o){for(let n=0;n<e.length;n+=3){const r=e[n+o];r>=s&&r<=i&&wt(t,e[n],e[n+1],e[n+2])}}function gt(e,t,s,i,o,n,r){let a=mt(e);const l=0===o?bt:vt;let c,h,u=e.start;for(let d=0;d<e.length-3;d+=3){const f=e[d],p=e[d+1],g=e[d+2],m=e[d+3],y=e[d+4],w=0===o?f:p,b=0===o?m:y;let v=!1;r&&(c=Math.sqrt(Math.pow(f-m,2)+Math.pow(p-y,2))),w<s?b>s&&(h=l(a,f,p,m,y,s),r&&(a.start=u+c*h)):w>i?b<i&&(h=l(a,f,p,m,y,i),r&&(a.start=u+c*h)):wt(a,f,p,g),b<s&&w>=s&&(h=l(a,f,p,m,y,s),v=!0),b>i&&w<=i&&(h=l(a,f,p,m,y,i),v=!0),!n&&v&&(r&&(a.end=u+c*h),t.push(a),a=mt(e)),r&&(u+=c)}let d=e.length-3;const f=e[d],p=e[d+1],g=0===o?f:p;g>=s&&g<=i&&wt(a,f,p,e[d+2]),d=a.length-3,n&&d>=3&&(a[d]!==a[0]||a[d+1]!==a[1])&&wt(a,a[0],a[1],a[2]),a.length&&t.push(a)}function mt(e){const t=[];return t.size=e.size,t.start=e.start,t.end=e.end,t}function yt(e,t,s,i,o,n){for(const r of e)gt(r,t,s,i,o,n,!1)}function wt(e,t,s,i){e.push(t,s,i)}function bt(e,t,s,i,o,n){const r=(n-t)/(i-t);return wt(e,n,s+(o-s)*r,1),r}function vt(e,t,s,i,o,n){const r=(n-s)/(o-s);return wt(e,t+(i-t)*r,n,1),r}function xt(e,t){const s=[];for(let i=0;i<e.length;i++){const o=e[i],n=o.type;let r;if("Point"===n||"MultiPoint"===n||"LineString"===n)r=It(o.geometry,t);else if("MultiLineString"===n||"Polygon"===n){r=[];for(const e of o.geometry)r.push(It(e,t))}else if("MultiPolygon"===n){r=[];for(const e of o.geometry){const s=[];for(const i of e)s.push(It(i,t));r.push(s)}}s.push(nt(o.id,n,r,o.tags))}return s}function It(e,t){const s=[];s.size=e.size,void 0!==e.start&&(s.start=e.start,s.end=e.end);for(let i=0;i<e.length;i+=3)s.push(e[i]+t,e[i+1],e[i+2]);return s}function St(e,t){if(e.transformed)return e;const s=1<<e.z,i=e.x,o=e.y;for(const n of e.features){const e=n.geometry,r=n.type;if(n.geometry=[],1===r)for(let r=0;r<e.length;r+=2)n.geometry.push(Mt(e[r],e[r+1],t,s,i,o));else for(let r=0;r<e.length;r++){const a=[];for(let n=0;n<e[r].length;n+=2)a.push(Mt(e[r][n],e[r][n+1],t,s,i,o));n.geometry.push(a)}}return e.transformed=!0,e}function Mt(e,t,s,i,o,n){return[Math.round(s*(e*i-o)),Math.round(s*(t*i-n))]}function Pt(e,t,s,i,o){const n=t===o.maxZoom?0:o.tolerance/((1<<t)*o.extent),r={features:[],numPoints:0,numSimplified:0,numFeatures:e.length,source:null,x:s,y:i,z:t,transformed:!1,minX:2,minY:1,maxX:-1,maxY:0};for(const t of e)Tt(r,t,n,o);return r}function Tt(e,t,s,i){const o=t.geometry,n=t.type,r=[];if(e.minX=Math.min(e.minX,t.minX),e.minY=Math.min(e.minY,t.minY),e.maxX=Math.max(e.maxX,t.maxX),e.maxY=Math.max(e.maxY,t.maxY),"Point"===n||"MultiPoint"===n)for(let t=0;t<o.length;t+=3)r.push(o[t],o[t+1]),e.numPoints++,e.numSimplified++;else if("LineString"===n)_t(r,o,e,s,!1,!1);else if("MultiLineString"===n||"Polygon"===n)for(let t=0;t<o.length;t++)_t(r,o[t],e,s,"Polygon"===n,0===t);else if("MultiPolygon"===n)for(let t=0;t<o.length;t++){const i=o[t];for(let t=0;t<i.length;t++)_t(r,i[t],e,s,!0,0===t)}if(r.length){let s=t.tags||null;if("LineString"===n&&i.lineMetrics){s={};for(const e in t.tags)s[e]=t.tags[e];s.mapbox_clip_start=o.start/o.size,s.mapbox_clip_end=o.end/o.size}const a={geometry:r,type:"Polygon"===n||"MultiPolygon"===n?3:"LineString"===n||"MultiLineString"===n?2:1,tags:s};null!==t.id&&(a.id=t.id),e.features.push(a)}}function _t(e,t,s,i,o,n){const r=i*i;if(i>0&&t.size<(o?r:i))return void(s.numPoints+=t.length/3);const a=[];for(let e=0;e<t.length;e+=3)(0===i||t[e+2]>r)&&(s.numSimplified++,a.push(t[e],t[e+1])),s.numPoints++;o&&function(e,t){let s=0;for(let t=0,i=e.length,o=i-2;t<i;o=t,t+=2)s+=(e[t]-e[o])*(e[t+1]+e[o+1]);if(s>0===t)for(let t=0,s=e.length;t<s/2;t+=2){const i=e[t],o=e[t+1];e[t]=e[s-2-t],e[t+1]=e[s-1-t],e[s-2-t]=i,e[s-1-t]=o}}(a,n),e.push(a)}const kt={maxZoom:14,indexMaxZoom:5,indexMaxPoints:1e5,tolerance:3,extent:4096,buffer:64,lineMetrics:!1,promoteId:null,generateId:!1,debug:0};class Lt{constructor(e,t){const s=(t=this.options=function(e,t){for(const s in t)e[s]=t[s];return e}(Object.create(kt),t)).debug;if(s&&console.time("preprocess data"),t.maxZoom<0||t.maxZoom>24)throw new Error("maxZoom should be in the 0-24 range");if(t.promoteId&&t.generateId)throw new Error("promoteId and generateId cannot be used together.");let i=function(e,t){const s=[];if("FeatureCollection"===e.type)for(let i=0;i<e.features.length;i++)at(s,e.features[i],t,i);else at(s,"Feature"===e.type?e:{geometry:e},t);return s}(e,t);this.tiles={},this.tileCoords=[],s&&(console.timeEnd("preprocess data"),console.log("index: maxZoom: %d, maxPoints: %d",t.indexMaxZoom,t.indexMaxPoints),console.time("generate tiles"),this.stats={},this.total=0),i=function(e,t){const s=t.buffer/t.extent;let i=e;const o=ft(e,1,-1-s,s,0,-1,2,t),n=ft(e,1,1-s,2+s,0,-1,2,t);return(o||n)&&(i=ft(e,1,-s,1+s,0,-1,2,t)||[],o&&(i=xt(o,1).concat(i)),n&&(i=i.concat(xt(n,-1)))),i}(i,t),i.length&&this.splitTile(i,0,0,0),s&&(i.length&&console.log("features: %d, points: %d",this.tiles[0].numFeatures,this.tiles[0].numPoints),console.timeEnd("generate tiles"),console.log("tiles generated:",this.total,JSON.stringify(this.stats)))}splitTile(e,t,s,i,o,n,r){const a=[e,t,s,i],l=this.options,c=l.debug;for(;a.length;){i=a.pop(),s=a.pop(),t=a.pop(),e=a.pop();const h=1<<t,u=zt(t,s,i);let d=this.tiles[u];if(!d&&(c>1&&console.time("creation"),d=this.tiles[u]=Pt(e,t,s,i,l),this.tileCoords.push({z:t,x:s,y:i}),c)){c>1&&(console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)",t,s,i,d.numFeatures,d.numPoints,d.numSimplified),console.timeEnd("creation"));const e=`z${t}`;this.stats[e]=(this.stats[e]||0)+1,this.total++}if(d.source=e,null==o){if(t===l.indexMaxZoom||d.numPoints<=l.indexMaxPoints)continue}else{if(t===l.maxZoom||t===o)continue;if(null!=o){const e=o-t;if(s!==n>>e||i!==r>>e)continue}}if(d.source=null,0===e.length)continue;c>1&&console.time("clipping");const f=.5*l.buffer/l.extent,p=.5-f,g=.5+f,m=1+f;let y=null,w=null,b=null,v=null,x=ft(e,h,s-f,s+g,0,d.minX,d.maxX,l),I=ft(e,h,s+p,s+m,0,d.minX,d.maxX,l);e=null,x&&(y=ft(x,h,i-f,i+g,1,d.minY,d.maxY,l),w=ft(x,h,i+p,i+m,1,d.minY,d.maxY,l),x=null),I&&(b=ft(I,h,i-f,i+g,1,d.minY,d.maxY,l),v=ft(I,h,i+p,i+m,1,d.minY,d.maxY,l),I=null),c>1&&console.timeEnd("clipping"),a.push(y||[],t+1,2*s,2*i),a.push(w||[],t+1,2*s,2*i+1),a.push(b||[],t+1,2*s+1,2*i),a.push(v||[],t+1,2*s+1,2*i+1)}}getTile(e,t,s){e=+e,t=+t,s=+s;const i=this.options,{extent:o,debug:n}=i;if(e<0||e>24)return null;const r=1<<e,a=zt(e,t=t+r&r-1,s);if(this.tiles[a])return St(this.tiles[a],o);n>1&&console.log("drilling down to z%d-%d-%d",e,t,s);let l,c=e,h=t,u=s;for(;!l&&c>0;)c--,h>>=1,u>>=1,l=this.tiles[zt(c,h,u)];return l&&l.source?(n>1&&(console.log("found parent tile z%d-%d-%d",c,h,u),console.time("drilling down")),this.splitTile(l.source,c,h,u,e,t,s),n>1&&console.timeEnd("drilling down"),this.tiles[a]?St(this.tiles[a],o):null):null}}function zt(e,t,s){return 32*((1<<e)*s+t)+e}function jt(e,t){const s=e.tileID.canonical;if(!this._geoJSONIndex)return void t(null,null);const i=this._geoJSONIndex.getTile(s.z,s.x,s.y);if(!i)return void t(null,null);const o=e=>e.tags&&"3d_elevation_id"in e.tags&&"source"in e.tags&&"elevation"===e.tags.source,n=i.features.filter(e=>o(e));let r={_geojsonTileLayer:i.features};n.length>0&&(r={_geojsonTileLayer:i.features.filter(e=>!o(e)),hd_road_elevation:n});const a=new ze(r),l=function(e){const t=new Z;for(const s of Object.keys(e))t.writeMessage(3,Ee,{name:s,features:e[s]});return t.finish()}(r).buffer;t(null,{vectorTile:a,rawData:l})}class Ct extends Se{constructor(e,t,s,i,o,n,r){super(e,t,s,i,o,jt,r),n&&(this.loadGeoJSON=n),this._dynamicIndex=new Ce}loadData(e,t){const s=e&&e.request,i=s&&s.collectResourceTiming;this._geoJSONIndex=null,this.loadGeoJSON(e,(o,n)=>{if(o||!n)return t(o);if("object"!=typeof n)return t(new Error(`Input data given to '${e.source}' is not a valid GeoJSON object.`));{try{if(e.filter){const t=V(e.filter,{type:"boolean","property-type":"data-driven",overridable:!1,transition:!1});if("error"===t.result)throw new Error(t.value.map(e=>`${e.key}: ${e.message}`).join(", "));n.features=n.features.filter(e=>t.value.evaluate({zoom:0},e))}e.dynamic?("Feature"===n.type&&(n={type:"FeatureCollection",features:[n]}),e.append||(this._dynamicIndex.clear(),this.loaded={}),this._dynamicIndex.load(n.features,this.loaded),e.cluster&&(n.features=this._dynamicIndex.getFeatures())):this.loaded={},this._geoJSONIndex=e.cluster?new He(function({superclusterOptions:e,clusterProperties:t}){if(!t||!e)return e;const s={},i={},o={accumulated:null,zoom:0},n={properties:null},r=Object.keys(t);for(const e of r){const[o,n]=t[e],r=V(n),a=V("string"==typeof o?[o,["accumulated"],["get",e]]:o);s[e]=r.value,i[e]=a.value}return e.map=e=>{n.properties=e;const t={};for(const e of r)t[e]=s[e].evaluate(o,n);return t},e.reduce=(e,t)=>{n.properties=t;for(const t of r)o.accumulated=e[t],e[t]=i[t].evaluate(o,n)},e}(e)).load(n.features):e.dynamic?this._dynamicIndex:function(e,t){return new Lt(e,t)}(n,e.geojsonVtOptions)}catch(e){return t(e)}const o={};if(i){const t=ae(s);t&&(o.resourceTiming={},o.resourceTiming[e.source]=JSON.parse(JSON.stringify(t)))}t(null,o)}})}reloadTile(e,t){const s=this.loaded;return s&&s[e.uid]?e.partial?t(null,void 0):super.reloadTile(e,t):this.loadTile(e,t)}loadGeoJSON(e,t){if(e.request)U(e.request,t);else{if("string"!=typeof e.data)return t(new Error(`Input data given to '${e.source}' is not a valid GeoJSON object.`));setTimeout(()=>{try{return t(null,JSON.parse(e.data))}catch(s){return t(new Error(`Input data given to '${e.source}' is not a valid GeoJSON object.`))}},0)}}getClusterExpansionZoom(e,t){try{t(null,this._geoJSONIndex.getClusterExpansionZoom(e.clusterId))}catch(e){t(e)}}getClusterChildren(e,t){try{t(null,this._geoJSONIndex.getChildren(e.clusterId))}catch(e){t(e)}}getClusterLeaves(e,t){try{t(null,this._geoJSONIndex.getLeaves(e.clusterId,e.limit,e.offset))}catch(e){t(e)}}}class Dt{constructor(e,t,s){this.tileID=new c(e.tileID.overscaledZ,e.tileID.wrap,e.tileID.canonical.z,e.tileID.canonical.x,e.tileID.canonical.y),this.tileZoom=e.tileZoom,this.uid=e.uid,this.zoom=e.zoom,this.canonical=e.tileID.canonical,this.pixelRatio=e.pixelRatio,this.tileSize=e.tileSize,this.source=e.source,this.overscaling=this.tileID.overscaleFactor(),this.projection=e.projection,this.brightness=t,this.worldview=s}parse(e,t,s,i){this.status="parsing";const o=new c(s.tileID.overscaledZ,s.tileID.wrap,s.tileID.canonical.z,s.tileID.canonical.x,s.tileID.canonical.y),n=[],r=t.familiesBySource[s.source],a=new f(o,s.promoteId);a.bucketLayerIDs=[],a.is3DTile=!0,q(e).then(e=>{const t=e.json.extensionsUsed&&e.json.extensionsUsed.includes("MAPBOX_mesh_features")||e.json.asset.extras&&e.json.asset.extras.MAPBOX_mesh_features,l=e.json.extensionsUsed&&e.json.extensionsUsed.includes("EXT_meshopt_compression"),c=new S(this.zoom,{brightness:this.brightness,worldview:this.worldview});for(const i in r)for(const h of r[i]){const i=h[0];a.bucketLayerIDs.push(h.map(e=>w(e.id,e.scope))),i.recalculate(c,[]);const r=W(e,1/Q(s.tileID.canonical)),u=new H(h,r,o,t,l,this.brightness,a,this.worldview);t||(u.needsUpload=!0),n.push(u),u.evaluate(i)}this.status="done",i(null,{buckets:n,featureIndex:a,collisionBoxArray:null,glyphAtlasImage:null,lineAtlas:null,imageAtlas:null,brightness:null})}).catch(e=>i(new Error(e.message)))}}class Ot{constructor(e,t,s,i,o,n,r,a){this.actor=e,this.layerIndex=t,this.availableImages=s,this.availableModels=i,this.brightness=r,this.loading={},this.loaded={},this.worldview=a}loadTile(e,t){const s=e.uid,i=this.loading[s]=new Dt(e,this.brightness,this.worldview);R(e.request,(o,n)=>{const r=!this.loading[s];return delete this.loading[s],r||o?(i.status="done",r||(this.loaded[s]=i),t(o)):n&&0!==n.byteLength?void i.parse(n,this.layerIndex,e,(e,o)=>{i.status="done",this.loaded=this.loaded||{},this.loaded[s]=i,e||!o?t(e):t(null,o)}):(i.status="done",this.loaded[s]=i,t())})}reloadTile(e,t){const s=this.loaded,i=e.uid;if(s&&s[i]){const o=s[i];o.projection=e.projection,o.brightness=e.brightness;const n=(s,i)=>{o.reloadCallback&&(delete o.reloadCallback,this.loadTile(e,t)),t(s,i)};"parsing"===o.status?o.reloadCallback=n:"done"===o.status&&this.loadTile(e,t)}}abortTile(e,t){const s=e.uid;this.loading[s]&&delete this.loading[s],t()}removeTile(e,t){const s=this.loaded,i=e.uid;s&&s[i]&&delete s[i],t()}}class Ft{constructor(e){this.self=e,this.actor=new ee(e,this),this.layerIndexes={},this.availableImages={},this.availableModels={},this.isSpriteLoaded={},this.imageRasterizer=new te,this.rtlPluginParsingListeners=[],this.projections={},this.defaultProjection=se({name:"mercator"}),this.workerSourceTypes={vector:Se,geojson:Ct,"raster-dem":Me,"raster-array":Te,"batched-model":Ot},this.workerSources={},this.self.registerWorkerSource=(e,t)=>{if(this.workerSourceTypes[e])throw new Error(`Worker source with name "${e}" already registered.`);this.workerSourceTypes[e]=t},this.self.registerRTLTextPlugin=e=>{if(oe.isParsed())throw new Error("RTL text plugin already registered.");oe.setState({pluginStatus:re.parsed,pluginURL:oe.getPluginURL()}),oe.applyArabicShaping=e.applyArabicShaping,oe.processBidirectionalText=e.processBidirectionalText,oe.processStyledBidirectionalText=e.processStyledBidirectionalText;for(const e of this.rtlPluginParsingListeners)e(null,!0);this.rtlPluginParsingListeners=[]}}clearCaches(e,t,s){delete this.layerIndexes[e],delete this.availableImages[e],delete this.availableModels[e],delete this.workerSources[e],s()}checkIfReady(e,t,s){s()}setReferrer(e,t){this.referrer=t}spriteLoaded(e,t){this.isSpriteLoaded[e]||(this.isSpriteLoaded[e]={});const{scope:s,isLoaded:i}=t;if(this.isSpriteLoaded[e][s]=i,this.workerSources[e]&&this.workerSources[e][s])for(const t in this.workerSources[e][s]){const o=this.workerSources[e][s][t];for(const e in o){const t=o[e];t instanceof Se&&(t.isSpriteLoaded=i,t.fire(new ie("isSpriteLoaded")))}}}setImages(e,t,s){this.availableImages[e]||(this.availableImages[e]={});const{scope:i,images:o}=t;if(this.availableImages[e][i]=o,this.workerSources[e]&&this.workerSources[e][i]){for(const t in this.workerSources[e][i]){const s=this.workerSources[e][i][t];for(const e in s)s[e].availableImages=o}s()}else s()}setModels(e,{scope:t,models:s},i){if(this.availableModels[e]||(this.availableModels[e]={}),this.availableModels[e][t]=s,this.workerSources[e]&&this.workerSources[e][t]){for(const i in this.workerSources[e][t]){const o=this.workerSources[e][t][i];for(const e in o)o[e].availableModels=s}i()}else i()}setProjection(e,t){this.projections[e]=se(t)}setBrightness(e,t,s){this.brightness=t,s()}setWorldview(e,t,s){this.worldview=t,s()}setLayers(e,t,s){this.getLayerIndex(e,t.scope).replace(t.layers,t.options),s()}updateLayers(e,t,s){this.getLayerIndex(e,t.scope).update(t.layers,t.removedIds,t.options),s()}loadTile(e,t,s){t.projection=this.projections[e]||this.defaultProjection,this.getWorkerSource(e,t.type,t.source,t.scope).loadTile(t,s)}decodeRasterArray(e,t,s){this.getWorkerSource(e,t.type,t.source,t.scope).decodeRasterArray(t,s)}reloadTile(e,t,s){t.projection=this.projections[e]||this.defaultProjection,this.getWorkerSource(e,t.type,t.source,t.scope).reloadTile(t,s)}abortTile(e,t,s){this.getWorkerSource(e,t.type,t.source,t.scope).abortTile(t,s)}removeTile(e,t,s){this.getWorkerSource(e,t.type,t.source,t.scope).removeTile(t,s)}removeSource(e,t,s){if(!(this.workerSources[e]&&this.workerSources[e][t.scope]&&this.workerSources[e][t.scope][t.type]&&this.workerSources[e][t.scope][t.type][t.source]))return;const i=this.workerSources[e][t.scope][t.type][t.source];delete this.workerSources[e][t.scope][t.type][t.source],void 0!==i.removeSource?i.removeSource(t,s):s()}loadWorkerSource(e,t,s){try{this.self.importScripts(t.url),s()}catch(e){s(e)}}syncRTLPluginState(e,t,s){if(oe.isParsed())s(null,!0);else if(oe.isParsing())this.rtlPluginParsingListeners.push(s);else try{oe.setState(t);const e=oe.getPluginURL();!oe.isLoaded()||oe.isParsed()||oe.isParsing()||null==e||(oe.setState({pluginStatus:re.parsing,pluginURL:oe.getPluginURL()}),this.self.importScripts(e),oe.isParsed()?s(null,!0):this.rtlPluginParsingListeners.push(s))}catch(e){s(e)}}setDracoUrl(e,t){this.dracoUrl=t}getAvailableImages(e,t){this.availableImages[e]||(this.availableImages[e]={});let s=this.availableImages[e][t];return s||(s=[]),s}getAvailableModels(e,t){this.availableModels[e]||(this.availableModels[e]={});let s=this.availableModels[e][t];return s||(s={}),s}getLayerIndex(e,t){this.layerIndexes[e]||(this.layerIndexes[e]={});let s=this.layerIndexes[e][t];return s||(s=this.layerIndexes[e][t]=new ue,s.scope=t),s}getWorkerSource(e,t,s,i){const o=this.workerSources;return o[e]||(o[e]={}),o[e][i]||(o[e][i]={}),o[e][i][t]||(o[e][i][t]={}),this.isSpriteLoaded[e]||(this.isSpriteLoaded[e]={}),o[e][i][t][s]||(o[e][i][t][s]=new this.workerSourceTypes[t]({send:(t,s,i,o,n,r)=>this.actor.send(t,s,i,e,n,r),scheduler:this.actor.scheduler},this.getLayerIndex(e,i),this.getAvailableImages(e,i),this.getAvailableModels(e,i),this.isSpriteLoaded[e][i],void 0,this.brightness,this.worldview)),o[e][i][t][s]}rasterizeImagesWorker(e,t,s){const i=new Map;for(const[s,{image:o,imageVariant:n}]of t.tasks.entries()){const r=this.imageRasterizer.rasterize(n,o,t.scope,e);i.set(s,r)}s(void 0,i)}removeRasterizedImages(e,t,s){this.imageRasterizer.removeImagesFromCacheByIds(t.imageIds,t.scope,e),s()}enforceCacheSizeLimit(e,t){ne(t)}getWorkerPerformanceMetrics(e,t,s){s(void 0,void 0)}}K(self)&&(self.worker=new Ft(self));export{Ft as default};//# sourceMappingURL=worker.js.map
